---
title: Tool execution
---

## Concepts

Molecule has several internal concepts to represent the different parts of the whole architecture. Among them there are:

- Strategy
- Runner
- Stager
- Controller
- Plan
- Execution
- Plugin
- Core



### Plugin

Molecule is an Integrated Development Environment, and as every IDE, it has to support different stacks and tools for the developer to have access to the everyday tooling he's used to work with. To make easier the integration of those tools, Molecule provide several APIs that handle a big part of the work required to integrate a tool.

Therefore a plugin is a link between Atom and the integrated tool, that define how molecule has to execute a tool and how the returned data has to be interpreted to provide a unified visualization to the developer.

A plugin is made of two parts: an Atom plugin and a NPM package.

This separation is made to allow Molecule to execute remotely the tools by installing them through NPM on the remote machine. The Atom plugin is made to handle the developer experience side of the tool, and so the user interface specific to the tool, and others details appearing only on Atom.

Each plugin can define handlers that will be called on different tool events, like a new output or the tool exit. Handlers are defined in the NPM package.

The code related to the loading of plugin is in ExecutionControlEpic/DevtoolLoadingFeature/

### Plan

Molecule provides to the developer reusable actions, that are ways of using a tool. For example, a build tool can provide a debug build action and a production build action. Molecule call them "plans" and the user interface is designed around them. Each plugin can provide a configuration for the user to configure plans, and can automatically generate some others.

A plan is basically a structure that contains an id, a name, the tool it comes from, the project it is associated with and a configuration. The configuration is custom and completely specific to the definition made by the plugin. It also contains information about whether the plan is automatically generated, if it has to be automatically launched and UI preferences.

The code related to plans is in ExecutionControlEpic/PlanConfigurationFeature/

### Strategy

The plan configuration depends on some user inputs, and so it is somehow a way for Molecule to save this input. But because the configuration is specific to each plugin, Molecule doesn't know what to do with it, it can't interpret what it means and how it will lead to a tool execution.

What Molecule can understand is a structure called strategy. A strategy is a definition of how to execute a tool. In simple words, it's a description of the method Molecule has to use to execute the tool. Many methods are available: through a shell, through a node fork process, through a pty. Each methods require different additional configuration attributes.

This description called strategy is generated by the plugin as a response to the plan configuration. So a plan configuration is sent to the plugin, which then generates a strategy from it.

The code related to strategies is in ExecutionControlEpic/LanguageServerProtocolFeature/Model/ 

### Runner

Once the strategy is generated, it is interpreted by what we call a runner. Each strategy has a type (a word describing the method) and each type is associated with a specific runner. The runner is called to run or stop a strategy.

It's basically a generic interface to make easy the addition of new ways of executing tools in Molecule. It provides a unified API for any kind of tool execution.

Because Molecule supports language servers (with the Language Server Protocol, LSP), each runner has the ability to define whether it supports it or not. Indeed, some strategy involves unreadable outputs (like the pty strategy which makes use of ansii codes) leading to the inability to parse the LSP. It's the role of the runner to tell this information to Molecule.

The code related to runners is in ExecutionControlEpic/LanguageServerProtocolFeature/Model/ 

### Controller

This whole strategy runner selection and execution is made by a part called Controller. The controller is made to interface the core of molecule with the strategy runner. It exists to allow Molecule to execute tools on remote machines. Molecule communicates with the controller through json-rpc with an extended Language Server Protocol. The Controller can be executed on a different process, machine or directly by the Molecule core through javascript.

It has the responsibility to execute the runner, to stop it, and to proxy data between the core and the runner. It also has the responsibility to call the plugin handlers.

The code related to the Controller is in ExecutionControlEpic/LanguageServerProtocolFeature/Model/ 

### Stager

Molecule has an architecture that allows it to execute tools remotely, and for that, it had to provide a way to execute strategy runners and so the controller at different places. This is the role of the stager.

The stager is a tunnel between the core of Molecule and the Controller. This tunnel works as a double stream and can be a simple process execution (Local Stager) which uses stdout/stdin or an SSH connection (Remote Stager) which uses the network.

It has many roles:

- to initiate the infrastructure to proxy data between the controller and the core
- to run the controller
- to provide an input stream, an output stream and an event emitter for specific events (controller killed, exit, etc ...).

The code related to stagers is in ExecutionControlEpic/LanguageServerProtocolFeature/Model/ 

### Core

#### Architecture

Molecule's Core uses Redux and the flux pattern. If you don't know this architecture I let you check here: https://facebook.github.io/flux/docs/in-depth-overview.html#content

In order to handle UI changes and input controls in a consistent way, we chose this architecture. All the molecule state is stored in the Redux state, and state changes lead to a UI refresh. Modifications to the state is made by reducers which receive actions. Actions are simple descriptions of events happening.

However, Molecule being a highly asynchronous environment, we chose to use redux-observable which allows us to work with RxJS (and so observables) to handle asynchronous parts.

Actions dispatched can trigger asynchronous behaviors, that dispatch themselves new actions. This handler which uses actions to dispatch other actions during asynchronous behaviors is called an Epic.

#### Epics

Epics are described here https://redux-observable.js.org/docs/basics/Epics.html.

In Molecule we use epics to handle many things, including stager execution, LSP communications with the Controller, events buffering and file events handling.

#### LSP Communications

LSP (Language Server Protocol) communications are made through and with the Controller. Those communications can notify the Core of many changes including the busy state of a process, new diagnostics, new terminal output. Some of the features are enhancements on the original Language Server Protocol, an extension made by us to handle features undefined in the protocol. 

If the process executed is ran by a strategy runner which supports language servers (and so is a language server), all the communications specified in the protocol are proxied by the Controller to the process. All the unspecified communications are only handled by the controller which knows what to do with it, without being proxied to the running process.

If the running process is not a language server, the Controller is the only handler of the messages.

### Execution

Each running process is linked to a structure called Execution with its task identifier. The role of the execution is to handle process specific state (eg: instance of terminal) and process specific events (eg: terminal resizes). Executions are then stored in a class called ExecutionController.

When an event (eg: a new terminal output) notifies the Core through LSP messages, Molecule's Core can get the corresponding execution with the task ID, and send the new output to the terminal instance this way.

#### States

Flux handles all the state which is serializable and linked to the UI. For all the non-serializable states (as terminal instances or network connections), separate stores are created. Those stores are simple map or lists encapsulated in a class. This class is generally named "SomethingController".